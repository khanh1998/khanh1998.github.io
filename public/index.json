[{"content":"B tree and B+ tree B tree is a self-balance tree. I can see that the B tree and AVL tree have a thing in common – it is all self-balance. But the difference is, each node in the AVL tree store exactly one value, and have at most two children. Each node of the B tree contains an array of at most N values and has at most N + 1 children.\nI am not gonna go into details about the B tree or B+ tree, you can read it on Wikipedia.\nHere are two very good demos on B tree and B+ tree, you can try them to understand how those trees work.\nHow does data get stored on a disk? The basic unit of a disk is a block. The size of a block is usually 512MB, which means that when you read, you have to read a whole block of 512MB. If you write, you have to write to a 512MB block.\n512MB is really large, so the database usually stores multiple records in the same block.\nIndex Database stores data in disk, so how do they find a specific record? Well, they have to scan through every record in the table to find your expected record, and IO operations are expensive. But that is when the database doesn’t have an index.\nIn simple words, an index is a way to map from a record identifier to its location on a disk. When using create a table, it usually comes with an index on the ID field, so that index is the mapping from ID to its record location on disk. Because the database stores multiple rows in a disk block, so, the location here is not exactly the location of the expected record, but the location of the block that contains the record. The database will read the whole block and return to you your desired record.\nSo, where does the indexes get stored? Well, on disk. Basically, indexes are additional data structures, it requires more space on the disk to store them.\nSo when a database wants to use an index, it has to read indexes from the disk.\nIs it slow? Yes, at first. The only needed block will be loaded to RAM, not all blocks of the index. But when a block gets accessed frequently, it will be cached, which could increase the performance.\nI have thought why wouldn’t load the whole index to RAM so we can access it quickly. Because the Index could be really big, and the idea of bringing the whole index to RAM is not possible.\nWhy B tree is a good fit for the database index? Why don’t use something like an AVL tree?\nAs I mentioned before, where we store data to disk, the basic unit is 512MB, so we want to put data to block as much as possible.\nSo each block now will store a list of mapping from Identifier to record block location.\nWhy B+ tree even better than Btree? The problem is IO operations are expensive and slow, so we want to avoid them, and the B+ tree helps us do that.\nB+ tree only stores key (or identifier) in a non-leaf node, which means one block now can store more mapping than before. B tree stores a list of pairs of a key and a location on a non-leaf node, it stores fewer mapping items per disk block.\nLet say, when using the B tree, we can store 100 mapping per disk block, but the B+ tree could possibly store 150 mapping per disk block.\nWhat does it mean? Each node in the B tree can have at most 101 children, but the B+ tree has at most 151 children. Each node in the B+ tree can store more information make the tree shorter when compared with the B tree.\nIn other words, in my example, read a block in B tree has time complexity O(log(n/100)), while the B+ tree has smaller time complexity O(log(n/150)). Where n = number of rows.\nDisadvantages of B+ tree When you use the B+ tree, even you found the key that you want, you still have to travel to the leaf node to take the value – location of the disk block contains the desired record.\nReferences https://stackoverflow.com/a/870324\nhttps://stackoverflow.com/a/1130\n","permalink":"https://khanh1998.github.io/posts/b-tree-and-indexing-in-database/","summary":"\u003ch2 id=\"b-tree-and-b-tree\"\u003eB tree and B+ tree\u003c/h2\u003e\n\u003cp\u003eB tree is a self-balance tree. I can see that the B tree and AVL tree have a thing in common – it is all self-balance. But the difference is, each node in the AVL tree store exactly one value, and have at most two children. Each node of the B tree contains an array of at most \u003cstrong\u003eN\u003c/strong\u003e values and has at most \u003cstrong\u003eN + 1\u003c/strong\u003e children.\u003c/p\u003e","title":"B tree, B+ tree, and indexing in database"},{"content":"1. Read phenomena When transaction A reads the data that might be changed by transaction B.\n1.1 Dirty reads: Is when a transaction read uncommitted data from another transaction. Example:\nTransaction A Transaction B begin transaction; select age from employee where id = 1; // age = 24 begin transaction; update employee set age = 25 where id = 1; // age = 25 select age from employee where id = 1; // age = 25 rollback; select age from employee where id = 1; // age = 24 commit; 1.2 Non-repeatable reads When during a transaction, you retrieve a row two times, and the second time, you got a slightly different row. It is different from the dirty read in that this time, it read committed data.\nTransaction A Transaction B begin transaction; select age from employee where id = 1; // age = 24 begin transaction; update employee set age = 25 where id = 1; // age = 25 commit; select age from employee where id = 1; // age = 25 commit; 1.3 Phantom read When during a transaction, you perform two queries, and the number of rows you got each time is different due to some other transaction inserting or deleting new data.\nTransaction A Transaction B begin transaction; select * from employee where age \u0026gt; 18 and age \u0026lt; 24; // 4 rows begin transaction; insert into employee(id, age) values(20); commit; select * from employee where age \u0026gt; 18 and age \u0026lt; 24; // 5 rows commit; 1.4 Serialization anomaly https://dba.stackexchange.com/a/315353\n2. Isolation level 2.1 Read uncommitted Transaction A could see uncommitted changes from Transaction B, in other words, it allows** dirty read** to happen.\n2.2 Read committed Transaction A could see committed changes from Transaction B. No dirty read at this level, but non-repeatable read and phantom read are possible.\n2.3 Repeatable reads It inherits from read-committed, and no non-repeatable read in this level, it means that no matter how many times you query for a row in a single transaction, you are a warranty that all the values in the row remain unchanged.\nBut phantom read could happen at this level.\n2.4 Serializable Not any read phenomena could happen at this level, this is the highest level of isolation.\nIn the Serializable Isolation Level, all transactions have to execute in sequential order, it cannot be executed in parallel like in the Repeatable level.\n3. Default Isolation level in Postgres The default isolation level of Postgres is Read Committed.\nThere is no way to read uncommitted in Postgres.\nPhantom-read is prevented even in Repeatable reads Isolation Level.\n4. References en.wikipedia.org/wiki/Isolation_(database_systems)\ndev.to/techschoolguru/understand-isolation-levels-read-phenomena-in-mysql-postgres-c2e\npostgresql.org/docs/current/transaction-iso.html\n","permalink":"https://khanh1998.github.io/posts/isolation-level-and-read-phenomena/","summary":"\u003ch2 id=\"1-read-phenomena\"\u003e1. Read phenomena\u003c/h2\u003e\n\u003cp\u003eWhen transaction A reads the data that might be changed by transaction B.\u003c/p\u003e\n\u003ch3 id=\"11-dirty-reads\"\u003e1.1 Dirty reads:\u003c/h3\u003e\n\u003cp\u003eIs when a transaction read uncommitted data from another transaction. Example:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e\u003cstrong\u003eTransaction A\u003c/strong\u003e\u003c/th\u003e\n          \u003cth style=\"text-align: right\"\u003e\u003cstrong\u003eTransaction B\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ebegin transaction;\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eselect age from employee where id = 1;\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e// age = 24\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003ebegin transaction;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003eupdate employee set age = 25 where id = 1;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e// age = 25\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eselect age from employee where id = 1;\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e// age = 25\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003erollback;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eselect age from employee where id = 1;\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e// age = 24\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ecommit;\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"12-non-repeatable-reads\"\u003e1.2 Non-repeatable reads\u003c/h3\u003e\n\u003cp\u003eWhen during a transaction, you retrieve a row two times, and the second time, you got a slightly different row. It is different from the dirty read in that this time, it read committed data.\u003c/p\u003e","title":"Isolation Level and Read Phenomena"},{"content":"Atomicity: Each transaction could have multiple steps in it, each step might be a query or an update to the data. Atomicity means that the transaction is considered a success if all steps are a success. If just one of those steps is failed, the whole transaction is considered to fail, and it has to roll back to the previous state.\nConsistency: In the database, it might have some rules or constraints, and the transaction when modified data have to follow those constraints. For example, let say the constrain for bank account balance is 0 or positive, so if a transaction tries to assign a negative number to a bank account, it violates the constrain and has to roll back.\nIsolation: At a time, there could be multiple transactions are trying to read or write to the database concurrently. There is nothing to say if all transactions are not trying to access or modify the same data, but in reality, they do a lot. So, the goal of isolation is to ensure that executing multiple transactions at the same time does not lead to a consistent state. They usually use a lock to achieve isolation in the database.\nDurability: This may be the easiest term to understand in ACID. Durability means once I have committed my transaction, my data will be in the database whenever I need it. The server could be down for some reason, but when it comes to online again, my data have to be ready to serve.\n","permalink":"https://khanh1998.github.io/posts/acid/","summary":"\u003cp\u003e\u003cstrong\u003eAtomicity\u003c/strong\u003e: Each transaction could have multiple steps in it, each step might be a query or an update to the data. Atomicity means that the transaction is considered a success if all steps are a success. If just one of those steps is failed, the whole transaction is considered to fail, and it has to roll back to the previous state.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsistency\u003c/strong\u003e: In the database, it might have some rules or constraints, and the transaction when modified data have to follow those constraints. For example, let say the constrain for bank account balance is 0 or positive, so if a transaction tries to assign a negative number to a bank account, it violates the constrain and has to roll back.\u003c/p\u003e","title":"ACID"},{"content":"So this is just a quick recap of what I have learned about networking\nFirst, you have to connect your computer to the local network. Your computer then will be assigned a local IP by a DHCP server (Dynamic Host Configuration Protocol), you cannot use that local IP to talk to the outside network. All the devices in the same local network will use the IP of the gateway to talk to the internet, sometimes it’s called public IP. The protocol to map from local address to public address is called NAT (Network Address Translation).\nGoogle.com is a URL, the computer doesn’t understand those names, they made those up so the human can remember them easier.\nTherefore, the first thing is to convert google.com to an IP address. The computer can do that using DNS protocol, each ISP will have a default DNS server, or you also can choose the DNS server that you want. So now you will have the IP of the server and be ready to make a connection.\nNow, the client will make a TCP connection to the server using a “three ways handshake“. After that, if we use HTTPS, then right after TCP connection is established, TLS/SSL handshake will happen, the server will send a TLS/SSL Certification and it’s the public key to the client, the client then verify to see if the certificate is valid or not.\nWhen the TCP connection is ready, the client can use HTTP/HTTPS protocol over TCP/IP protocol to talk to the server to request resources.\nHTTP -\u0026gt; TCP -\u0026gt; IP -\u0026gt; PPP\nTCP is a protocol to exchange messages between two processes, could be in the same or different machine. We usually see TCP come with IP, IP is another protocol to exchange messages between two hosts.\nBellow IP protocol could be PPP (Point to Point Protocol). So the IP package is transferred by PPP, and PPP doesn’t use an IP address, it uses MAC Address instead. So there is an ARP (Address Resolution Protocol) to get MAC addresses of surrounding hosts.\n","permalink":"https://khanh1998.github.io/posts/what-happen-when-you-use-a-browser-to-access-google/","summary":"\u003cp\u003eSo this is just a quick recap of what I have learned about networking\u003c/p\u003e\n\u003cp\u003eFirst, you have to connect your computer to the local network. Your computer then will be assigned a local IP by a \u003cstrong\u003eDHCP\u003c/strong\u003e server (Dynamic Host Configuration Protocol), you cannot use that local IP to talk to the outside network. All the devices in the same local network will use the IP of the gateway to talk to the internet, sometimes it’s called public IP. The protocol to map from local address to public address is called \u003cstrong\u003eNAT\u003c/strong\u003e (Network Address Translation).\u003c/p\u003e","title":"What happens when you use a browser to access google.com"}]