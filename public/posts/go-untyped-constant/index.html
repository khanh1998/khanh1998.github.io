<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go | Khanh1998</title>
<meta name=keywords content="go,cs"><meta name=description content="You may have heard about 0.1 + 0.2 != 0.3 already, it’s a common issue in most programming languages. The reason behind that is the floating point (IEEE 754) as the computer can’t represent exactly a decimal in binary. By utilizing the floating point, the computer can hold a very large decimal, but the trade-off is it now can only represent the approximate of the true value.
However, in this post, I will not explain how floating point works but something else – constant."><meta name=author content="Khanh Bui"><link rel=canonical href=https://khanh1998.github.io/posts/go-untyped-constant/><meta name=google-site-verification content="Siuz-KNzTaGnjWViVxoA0J6xLTJQtxwpsh9L7HHMNnA"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://khanh1998.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://khanh1998.github.io/posts/go-untyped-constant/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y0MCHJNHTB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y0MCHJNHTB")}</script><meta property="og:url" content="https://khanh1998.github.io/posts/go-untyped-constant/"><meta property="og:site_name" content="Khanh1998"><meta property="og:title" content="Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go"><meta property="og:description" content="You may have heard about 0.1 + 0.2 != 0.3 already, it’s a common issue in most programming languages. The reason behind that is the floating point (IEEE 754) as the computer can’t represent exactly a decimal in binary. By utilizing the floating point, the computer can hold a very large decimal, but the trade-off is it now can only represent the approximate of the true value.
However, in this post, I will not explain how floating point works but something else – constant."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-10T13:57:02+07:00"><meta property="article:modified_time" content="2023-09-10T13:57:02+07:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Cs"><meta property="og:image" content="https://khanh1998.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://khanh1998.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go"><meta name=twitter:description content="You may have heard about 0.1 + 0.2 != 0.3 already, it’s a common issue in most programming languages. The reason behind that is the floating point (IEEE 754) as the computer can’t represent exactly a decimal in binary. By utilizing the floating point, the computer can hold a very large decimal, but the trade-off is it now can only represent the approximate of the true value.
However, in this post, I will not explain how floating point works but something else – constant."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://khanh1998.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go","item":"https://khanh1998.github.io/posts/go-untyped-constant/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go","name":"Why would sometimes 0.1 \u002b 0.2 equals to 0.3, but sometimes it’s not in Go","description":"You may have heard about 0.1 + 0.2 != 0.3 already, it’s a common issue in most programming languages. The reason behind that is the floating point (IEEE 754) as the computer can’t represent exactly a decimal in binary. By utilizing the floating point, the computer can hold a very large decimal, but the trade-off is it now can only represent the approximate of the true value.\nHowever, in this post, I will not explain how floating point works but something else – constant.\n","keywords":["go","cs"],"articleBody":"You may have heard about 0.1 + 0.2 != 0.3 already, it’s a common issue in most programming languages. The reason behind that is the floating point (IEEE 754) as the computer can’t represent exactly a decimal in binary. By utilizing the floating point, the computer can hold a very large decimal, but the trade-off is it now can only represent the approximate of the true value.\nHowever, in this post, I will not explain how floating point works but something else – constant.\nUntyped constant First, let’s take a look at my Go sample code, throughout this post, I will try to explain what is going on.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://go.dev/play/p/fdBVcZqFyB1 package main import \"fmt\" func main() { // first example a := 0.1 + 0.2 b := 0.3 fmt.Println(a == b) // true // second example x := float64(0.1) + float64(0.2) y := float64(0.3) fmt.Println(x == y) // false } it’s weird right? sometimes 0.1 + 0.2 is equal to 0.3, but sometimes it is not.\nThe thing that caused the above issue which named untyped constant. In Go (and some other languages), an untyped contact can have arbitrary precision, simply put, untyped constants are much more precise than floating point.\nThere is a Pi constant in the math library:\n1 Pi = 3.14159265358979323846264338327950288419716939937510582097494459 The precision of the constant Pi is much more than normal float64, if you assign Pi to a variable, it will lose some precision.\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" \"math\" ) func main() { pi := math.Pi fmt.Println(pi) // 3.141592653589793 } With the untyped constant like the above Pi, the language allows you to do math calculations with higher precision, like the below example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \"fmt\" \"math\" ) const r = 589.897962323243 // untyped const func main() { ra := r fmt.Println(math.Pi * r * r / 180) // result: 6073.389853674304 fmt.Println(math.Pi * ra * ra / 180) // result: 6073.389853674303 } In the expression of math.Pi * r * r / 180, there are three untyped constants, math.Pi, r, and 180. In the second expression, math.Pi * ra * ra / 180, we know that math.Pi and 180 are untyped constants, but ra is a float64 variable and it causes the result less precision because the computer can’t represent exactly the decimal of 589.897962323243 in binary.\nNow back to the first code snippet. 0.1, 0.2, and 0.3 are untyped constants. These untyped constants allow you to make high-precision calculations. If you think 0.1, 0.2, and 0.3 are floating point, you are totally wrong. Like the first example, 0.1 + 0.2 = 0.3, you know that floating points can only represent an approximate true value, so no way 0.1 + 0.2 equals 0.3. So floating point has nothing to do with the calculation of 0.1 + 0.2. Thanks to the untyped constants, it is the reason you get the expected in the first example.\nAn untyped constant can:\nhave very higher precision than floating point It never overflows – meaning you can store a very large number But when you assign an untyped constant to a variable like float64, it will lose some precision, and the untyped constant value needs to fit in a float64, if the constant value is too big, there will be an error.\nThis leads us to the second example, float64(0.1) + float64(0.2). We know that 0.1 and 0.2 are untyped constants. but when we assign them to float64, we lose some precision. It means float64(0.1) doesn’t equal 0.1, likewise to 0.2 or 0.3. so when we add two float representations of 0.1 and 0.2, the result is not 0.3, but a value that approximates 0.3. For the float64(0.3), the language can only represent an approximate value of 0.3 as well.\nfloat(0.1) -\u003e approximate value of 0.1 float(0.2) -\u003e approximate value of 0.2 float(0.1) + float(0.2) -\u003e you are adding two approximate values -\u003e approximate value of 0.3 (1) float(0.3) -\u003e approximate value of 0.3 (2) (1) and (3) are two approximate values of three, but they can be different. fmt.Println By default, to be able to print the constant, the constant needs to be assigned to a variable, and that causes a loss of some precision. Take a look at the below example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \"fmt\" ) func main() { fmt.Println(0.3) // 0.3 fmt.Printf(\"%f\\n\", 0.30000000000000001) // 0.300000 fmt.Printf(\"%.16f\\n\", 0.30000000000000001) // 0.3000000000000000 fmt.Printf(\"%.54f\\n\", 0.30000000000000001) // 0.299999999999999988897769753748434595763683319091796875 fmt.Printf(\"%.54f\\n\", 0.3) // 0.299999999999999988897769753748434595763683319091796875 } All of the constants in the above example are untyped, meaning it has very high precision, but the untyped constants like 0.3 need to be converted to float64, so that the fmt.Println can print it to the console, and the conversion from untyped constant to float64 will cause some minor imprecision.\nfmt.Println(0.3) -\u003e 0.3 in the console, that’s weird, right? 0.3 is an untyped constant, the fmt.Println needs to cast 0.3 to a float64, which will make the value lose some precision, That means it can’t print 0.3, it has to be some approximate value right? fmt.Printf(“%f\\n”, 0.30000000000000001) -\u003e 0.300000. So that seems like fmt.Println round the input float64. And default it rounds to 6 digits after the decimal point. fmt.Printf(“%.16f\\n”, 0.30000000000000001) -\u003e 0.3000000000000000. If you round up the float to 16 digits, you get 0.3. That is true, Let’s try rounding up 0.2999999999999999, and you will get 0.3. fmt.Printf(“%.54f\\n”, 0.30000000000000001) -\u003e 0.299999999999999988897769753748434595763683319091796875. With 54 digits after the decimal point, you now know the closest value to 0.3 can be represented in binary. References https://en.wikipedia.org/wiki/IEEE_754 https://go.dev/blog/constants https://go.dev/ref/spec#Constants https://go.dev/ref/spec#Constant_expressions https://stackoverflow.com/questions/38982278/how-does-go-perform-arithmetic-on-constants https://stackoverflow.com/questions/57511935/what-is-the-purpose-of-arbitrary-precision-constants-in-go?rq=3 https://stackoverflow.com/questions/38806491/why-doesnt-left-bit-shifting-by-64-overflow-in-golang https://stackoverflow.com/questions/58403028/floating-point-precision-golang https://stackoverflow.com/questions/42153747/why-does-0-1-0-2-get-0-3-in-google-go\n","wordCount":"971","inLanguage":"en","image":"https://khanh1998.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-09-10T13:57:02+07:00","dateModified":"2023-09-10T13:57:02+07:00","author":{"@type":"Person","name":"Khanh Bui"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://khanh1998.github.io/posts/go-untyped-constant/"},"publisher":{"@type":"Organization","name":"Khanh1998","logo":{"@type":"ImageObject","url":"https://khanh1998.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://khanh1998.github.io/ accesskey=h title="Khanh1998 (Alt + H)"><img src=https://khanh1998.github.io/favicon.ico alt aria-label=logo height=32>Khanh1998</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://khanh1998.github.io/vi/ title="Tiếng Việt" aria-label="Tiếng Việt">Vi</a></li></ul></div></div><ul id=menu><li><a href=https://khanh1998.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://khanh1998.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://khanh1998.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://khanh1998.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://khanh1998.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go</h1><div class=post-meta><span title='2023-09-10 13:57:02 +0700 +07'>September 10, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;971 words&nbsp;·&nbsp;Khanh Bui&nbsp;|&nbsp;<a href=https://github.com/khanh1998/khanh1998.github.io/blob/main/content/posts/go-untyped-constant.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#untyped-constant>Untyped constant</a></li><li><a href=#fmtprintln>fmt.Println</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>You may have heard about <em>0.1 + 0.2 != 0.3</em> already, it’s a common issue in most programming languages. The reason behind that is the floating point (IEEE 754) as the computer can’t represent exactly a decimal in binary. By utilizing the floating point, the computer can hold a very large decimal, but the trade-off is it now can only represent the approximate of the true value.</p><p>However, in this post, I will not explain how floating point works but something else – <a href=https://go.dev/blog/constants>constant</a>.</p><h2 id=untyped-constant>Untyped constant<a hidden class=anchor aria-hidden=true href=#untyped-constant>#</a></h2><p>First, let’s take a look at my <a href=https://go.dev/play/p/fdBVcZqFyB1>Go sample code</a>, throughout this post, I will try to explain what is going on.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// https://go.dev/play/p/fdBVcZqFyB1</span>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// first example</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=o>:=</span> <span class=mf>0.1</span> <span class=o>+</span> <span class=mf>0.2</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=o>:=</span> <span class=mf>0.3</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>a</span> <span class=o>==</span> <span class=nx>b</span><span class=p>)</span> <span class=c1>// true</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// second example</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span> <span class=o>:=</span> <span class=nb>float64</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span> <span class=o>+</span> <span class=nb>float64</span><span class=p>(</span><span class=mf>0.2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span> <span class=o>:=</span> <span class=nb>float64</span><span class=p>(</span><span class=mf>0.3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span> <span class=o>==</span> <span class=nx>y</span><span class=p>)</span> <span class=c1>// false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>it’s weird right? sometimes 0.1 + 0.2 is equal to 0.3, but sometimes it is not.</p><p>The thing that caused the above issue which named <em>untyped constant</em>. In Go (and some other languages), an untyped contact can have <em>arbitrary precision</em>, simply put, <em>untyped constants</em> are much more <strong>precise</strong> than floating point.</p><p>There is a Pi constant in the <code>math</code> library:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>Pi</span>  <span class=p>=</span> <span class=mf>3.14159265358979323846264338327950288419716939937510582097494459</span>
</span></span></code></pre></td></tr></table></div></div><p>The precision of the constant <code>Pi</code> is much more than normal <code>float64</code>, if you assign <code>Pi</code> to a variable, it will lose some precision.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;math&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pi</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>pi</span><span class=p>)</span> <span class=c1>// 3.141592653589793</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>With the <em>untyped constant</em> like the above <code>Pi</code>, the language allows you to do math calculations with higher precision, like the below example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;math&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>r</span> <span class=p>=</span> <span class=mf>589.897962323243</span> <span class=c1>// untyped const</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ra</span> <span class=o>:=</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span> <span class=o>*</span> <span class=nx>r</span> <span class=o>*</span> <span class=nx>r</span> <span class=o>/</span> <span class=mi>180</span><span class=p>)</span>   <span class=c1>// result: 6073.389853674304</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span> <span class=o>*</span> <span class=nx>ra</span> <span class=o>*</span> <span class=nx>ra</span> <span class=o>/</span> <span class=mi>180</span><span class=p>)</span> <span class=c1>// result: 6073.389853674303</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In the expression of <code>math.Pi * r * r / 180</code>, there are three <em>untyped constants</em>, <code>math.Pi</code>, <code>r</code>, and <code>180</code>. In the second expression, <code>math.Pi * ra * ra / 180</code>, we know that <code>math.Pi</code> and <code>180</code> are <em>untyped constants</em>, but <code>ra</code> is a <code>float64</code> variable and it causes the result less precision because the computer can’t represent exactly the decimal of <code>589.897962323243</code> in binary.</p><p>Now back to the first code snippet. <code>0.1</code>, <code>0.2</code>, and <code>0.3</code> are <em>untyped constants</em>. These <em>untyped constants</em> allow you to make high-precision calculations. If you think <code>0.1</code>, <code>0.2</code>, and <code>0.3</code> are floating point, you are totally wrong. Like the first example, <code>0.1 + 0.2 = 0.3</code>, you know that floating points can only represent an approximate true value, so no way <code>0.1 + 0.2</code> equals <code>0.3</code>. So floating point has nothing to do with the calculation of <code>0.1 + 0.2</code>. Thanks to the <em>untyped constants</em>, it is the reason you get the expected in the first example.</p><p>An untyped constant can:</p><ul><li>have very higher precision than floating point</li><li>It never overflows – meaning you can store a very large number</li></ul><p>But when you assign an <em>untyped constant</em> to a <em>variable</em> like <code>float64</code>, it will lose some precision, and the <em>untyped constant</em> value needs to fit in a <code>float64</code>, if the constant value is too big, there will be an error.</p><p>This leads us to the second example, <code>float64(0.1) + float64(0.2)</code>. We know that <code>0.1</code> and <code>0.2</code> are <em>untyped constants</em>. but when we assign them to <code>float64</code>, we lose some precision. It means <code>float64(0.1)</code> doesn’t equal <code>0.1</code>, likewise to <code>0.2</code> or <code>0.3</code>. so when we add two float representations of <code>0.1</code> and <code>0.2</code>, the result is not <code>0.3</code>, but a value that approximates <code>0.3</code>. For the <code>float64(0.3)</code>, the language can only represent an approximate value of <code>0.3</code> as well.</p><ul><li><code>float(0.1)</code> -> approximate value of <code>0.1</code></li><li><code>float(0.2)</code> -> approximate value of <code>0.2</code></li><li><code>float(0.1) + float(0.2)</code> -> you are adding two approximate values -> approximate value of <code>0.3</code> <strong>(1)</strong></li><li><code>float(0.3)</code> -> approximate value of <code>0.3</code> <strong>(2)</strong></li><li><strong>(1)</strong> and <strong>(3)</strong> are two approximate values of three, but they can be different.</li></ul><h2 id=fmtprintln>fmt.Println<a hidden class=anchor aria-hidden=true href=#fmtprintln>#</a></h2><p>By default, to be able to print the constant, the constant needs to be assigned to a variable, and that causes a loss of some precision. Take a look at the below example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mf>0.3</span><span class=p>)</span>                           <span class=c1>// 0.3</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%f\n&#34;</span><span class=p>,</span> <span class=mf>0.30000000000000001</span><span class=p>)</span>    <span class=c1>// 0.300000</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%.16f\n&#34;</span><span class=p>,</span> <span class=mf>0.30000000000000001</span><span class=p>)</span> <span class=c1>// 0.3000000000000000</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%.54f\n&#34;</span><span class=p>,</span> <span class=mf>0.30000000000000001</span><span class=p>)</span> <span class=c1>// 0.299999999999999988897769753748434595763683319091796875</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%.54f\n&#34;</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>)</span>                 <span class=c1>// 0.299999999999999988897769753748434595763683319091796875</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>All of the constants in the above example are <em>untyped</em>, meaning it has very high precision, but the untyped constants like <code>0.3</code> need to be converted to <code>float64</code>, so that the <code>fmt.Println</code> can print it to the console, and the conversion from <em>untyped constant</em> to <code>float64</code> will cause some minor imprecision.</p><ul><li><code>fmt.Println(0.3)</code> -> <code>0.3</code> in the console, that’s weird, right? <code>0.3</code> is an <em>untyped constant</em>, the <code>fmt.Println</code> needs to cast <code>0.3</code> to a <code>float64</code>, which will make the value lose some precision, That means it can’t print <code>0.3</code>, it has to be some approximate value right?</li><li><code>fmt.Printf(“%f\n”, 0.30000000000000001)</code> -> <code>0.300000</code>. So that seems like <code>fmt.Println</code> round the input <code>float64</code>. And default it rounds to <strong>6 digits</strong> after the decimal point.</li><li><code>fmt.Printf(“%.16f\n”, 0.30000000000000001)</code> -> <code>0.3000000000000000</code>. If you round up the float to 16 digits, you get <code>0.3</code>. That is true, Let’s try rounding up <code>0.2999999999999999</code>, and you will get <code>0.3</code>.</li><li><code>fmt.Printf(“%.54f\n”, 0.30000000000000001)</code> -> <code>0.299999999999999988897769753748434595763683319091796875</code>. With 54 digits after the decimal point, you now know the closest value to <code>0.3</code> can be represented in binary.</li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://en.wikipedia.org/wiki/IEEE_754>https://en.wikipedia.org/wiki/IEEE_754</a>
<a href=https://go.dev/blog/constants>https://go.dev/blog/constants</a>
<a href=https://go.dev/ref/spec#Constants>https://go.dev/ref/spec#Constants</a>
<a href=https://go.dev/ref/spec#Constant_expressions>https://go.dev/ref/spec#Constant_expressions</a>
<a href=https://stackoverflow.com/questions/38982278/how-does-go-perform-arithmetic-on-constants>https://stackoverflow.com/questions/38982278/how-does-go-perform-arithmetic-on-constants</a>
<a href="https://stackoverflow.com/questions/57511935/what-is-the-purpose-of-arbitrary-precision-constants-in-go?rq=3">https://stackoverflow.com/questions/57511935/what-is-the-purpose-of-arbitrary-precision-constants-in-go?rq=3</a>
<a href=https://stackoverflow.com/questions/38806491/why-doesnt-left-bit-shifting-by-64-overflow-in-golang>https://stackoverflow.com/questions/38806491/why-doesnt-left-bit-shifting-by-64-overflow-in-golang</a>
<a href=https://stackoverflow.com/questions/58403028/floating-point-precision-golang>https://stackoverflow.com/questions/58403028/floating-point-precision-golang</a>
<a href=https://stackoverflow.com/questions/42153747/why-does-0-1-0-2-get-0-3-in-google-go>https://stackoverflow.com/questions/42153747/why-does-0-1-0-2-get-0-3-in-google-go</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://khanh1998.github.io/tags/go/>Go</a></li><li><a href=https://khanh1998.github.io/tags/cs/>Cs</a></li></ul><nav class=paginav><a class=prev href=https://khanh1998.github.io/posts/go-pointer-value-receiver/><span class=title>« Prev</span><br><span>The pointer receiver and value receiver in Go are just syntax sugar</span>
</a><a class=next href=https://khanh1998.github.io/posts/a-note-about-rust-smart-pointer-and-deref/><span class=title>Next »</span><br><span>A Note About Rust Smart Pointer and Deref</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on x" href="https://x.com/intent/tweet/?text=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go&amp;url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f&amp;hashtags=go%2ccs"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f&amp;title=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go&amp;summary=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go&amp;source=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f&title=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on whatsapp" href="https://api.whatsapp.com/send?text=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go%20-%20https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on telegram" href="https://telegram.me/share/url?text=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go&amp;url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go on ycombinator" href="https://news.ycombinator.com/submitlink?t=Why%20would%20sometimes%200.1%20%2b%200.2%20equals%20to%200.3%2c%20but%20sometimes%20it%e2%80%99s%20not%20in%20Go&u=https%3a%2f%2fkhanh1998.github.io%2fposts%2fgo-untyped-constant%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//khanh1998.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://khanh1998.github.io/>Khanh1998</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>