<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Note About Rust Smart Pointer and Deref | Khanh1998</title>
<meta name=keywords content="rust,cs"><meta name=description content="this article assumes you have some basic knowledge about Rust smart pointers.
the dereference (*) operator
dereference operator * is used for getting the actual value from a reference:


1
2
3


let a: i32 = 5;    
let b: &amp;i32 = &amp;a;
assert_eq!(*b, 5);


in the above example, b is a reference to a, *b will return the value that b pointing to.
the smart pointers
Box<T>
here is an example of how you can init and modify the value of a Box:"><meta name=author content="Khanh Bui"><link rel=canonical href=https://khanh1998.github.io/posts/a-note-about-rust-smart-pointer-and-deref/><meta name=google-site-verification content="Siuz-KNzTaGnjWViVxoA0J6xLTJQtxwpsh9L7HHMNnA"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://khanh1998.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://khanh1998.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://khanh1998.github.io/posts/a-note-about-rust-smart-pointer-and-deref/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y0MCHJNHTB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y0MCHJNHTB")}</script><meta property="og:title" content="A Note About Rust Smart Pointer and Deref"><meta property="og:description" content="this article assumes you have some basic knowledge about Rust smart pointers.
the dereference (*) operator
dereference operator * is used for getting the actual value from a reference:


1
2
3


let a: i32 = 5;    
let b: &amp;i32 = &amp;a;
assert_eq!(*b, 5);


in the above example, b is a reference to a, *b will return the value that b pointing to.
the smart pointers
Box<T>
here is an example of how you can init and modify the value of a Box:"><meta property="og:type" content="article"><meta property="og:url" content="https://khanh1998.github.io/posts/a-note-about-rust-smart-pointer-and-deref/"><meta property="og:image" content="https://khanh1998.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-11T13:33:55+07:00"><meta property="article:modified_time" content="2022-12-11T13:33:55+07:00"><meta property="og:site_name" content="Khanh1998"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://khanh1998.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="A Note About Rust Smart Pointer and Deref"><meta name=twitter:description content="this article assumes you have some basic knowledge about Rust smart pointers.
the dereference (*) operator
dereference operator * is used for getting the actual value from a reference:


1
2
3


let a: i32 = 5;    
let b: &amp;i32 = &amp;a;
assert_eq!(*b, 5);


in the above example, b is a reference to a, *b will return the value that b pointing to.
the smart pointers
Box<T>
here is an example of how you can init and modify the value of a Box:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://khanh1998.github.io/posts/"},{"@type":"ListItem","position":2,"name":"A Note About Rust Smart Pointer and Deref","item":"https://khanh1998.github.io/posts/a-note-about-rust-smart-pointer-and-deref/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Note About Rust Smart Pointer and Deref","name":"A Note About Rust Smart Pointer and Deref","description":"this article assumes you have some basic knowledge about Rust smart pointers.\nthe dereference (*) operator dereference operator * is used for getting the actual value from a reference:\n1 2 3 let a: i32 = 5; let b: \u0026amp;i32 = \u0026amp;a; assert_eq!(*b, 5); in the above example, b is a reference to a, *b will return the value that b pointing to.\nthe smart pointers Box\u0026lt;T\u0026gt; here is an example of how you can init and modify the value of a Box:\n","keywords":["rust","cs"],"articleBody":"this article assumes you have some basic knowledge about Rust smart pointers.\nthe dereference (*) operator dereference operator * is used for getting the actual value from a reference:\n1 2 3 let a: i32 = 5; let b: \u0026i32 = \u0026a; assert_eq!(*b, 5); in the above example, b is a reference to a, *b will return the value that b pointing to.\nthe smart pointers Box here is an example of how you can init and modify the value of a Box:\n1 2 3 let mut b: Box\u003ci32\u003e = Box::new(6); *b = 7; assert_eq!(*b, 7); in the above example, I init a box with value 6 inside, then I changed the value to 7, and check the value inside the box with assert to ensure the change is affected.\nin the first example of this post, we apply the dereference to a reference which is \u0026i32, but the data type of b now is Box, how can we apply to dereference to a Box?\nthe answer is the Box is implemented the trait Deref and DerefMut, so when you write *b, the compiler implicitly translates it to *(b.deref()) if you want to get the value or *(b.deref_mut()) if you want to change the value.\nif you have a Box, the deref method returns a \u0026T, and deref_mut returns a \u0026mut T. after calling the deref method, you now have a reference to the actual value, therefore you can use the dereference operator on these references.\nthe above snippet can be explicitly rewritten as below:\n1 2 3 4 5 6 7 let mut b: Box\u003ci32\u003e = Box::new(6); let c: \u0026mut i32 = b.deref_mut(); *c = 7; let d: \u0026i32 = b.deref(); assert_eq!(*d, 7); firstly, we create a new box to hold the value 6. then we call deref_mut to get a \u0026mut i32, in order to change the value inside the box. finally, we get a read-only reference \u0026i32 to the value inside the box, by calling deref.\nRc Rc is quite similar to Box, except that you can only read data in Rc, you cannot edit it. because Rc only implements the trait Deref, not implement DerefMut. Therefore, you can only call the deref method on Rc only, there is no such method deref_mut.\n1 2 3 4 5 6 // implicitly let rc1 = Rc::new(3); assert_eq!(*rc1, 3); // explicitly let a = rc1.deref(); assert_eq!(*a, 3); RefCell 1 2 3 4 // wrong code let ref_cell: RefCell\u003ci32\u003e = RefCell::new(5); *ref_cell = 7; assert_eq!(*ref_cell, 7); if you write code like the above example, you will get this error: type RefCell\u003c{integer}\u003e cannot be dereferenced. it’s because RefCell doesn’t implement either Deref or DerefMut traits. you can check this out on the docs of RefCell.\nthe way RefCell works is a bit different from Box, to read or modify data inside RefCell you need to explicitly call method borrow or borrow_mut respectively.\nborrow will return a Ref which implements trait Deref, and borrow_mut will return a RefMut which implements both DerefMut and Deref.\nbecause Ref and RefMut implements Deref, so we can use dereference operator on them.\nso you can write code like this:\n1 2 3 4 5 6 7 8 9 // implicit let ref_cell = RefCell::new(5); *(ref_cell.borrow_mut()) = 7; assert_eq!(*(ref_cell.borrow()), 7); // a bit explicit let ref_cell = RefCell::new(5); *(ref_cell.borrow_mut().deref_mut()) = 7; assert_eq!(*(ref_cell.borrow().deref()), 7); or, if you want more explicitly, I have this code:\n1 2 3 4 5 6 7 8 9 10 // wrong code let ref_cell = RefCell::new(5); let mut a: RefMut\u003ci32\u003e = ref_cell.borrow_mut(); let b: \u0026mut i32 = a.deref_mut(); *b = 8; let a: Ref\u003ci32\u003e = ref_cell.borrow(); let b: \u0026i32 = a.deref(); assert_eq!(*b, 8); if you run the above code, you will get this error: already mutably borrowed: BorrowError.\nit’s because, in line number 2, you call borrow_mut, and in line number 3 you call deref_mut to get a mutability reference.\nin line number 5, you call borrow in order to read the data inside RefCell, which is forbidden by Rust. you can’t have a read-only reference to the value that currently has a mutability reference to prevent the race condition. so you can rewrite it as below:\n1 2 3 4 5 6 7 8 9 10 11 12 let ref_cell = RefCell::new(5); { let mut a: RefMut\u003ci32\u003e = ref_cell.borrow_mut(); let b: \u0026mut i32 = a.deref_mut(); *b = 8; } // borrow_mut will be drop here, at the end of block { // there are no mutability reference to the value, so we can borrow. let a: Ref\u003ci32\u003e = ref_cell.borrow(); let b: \u0026i32 = a.deref(); assert_eq!(*b, 8); } in the above code, the borrow_mut and deref_mut are put in the first block, so at the end of the first block, the mutability reference is dropped, there is no mutability reference to the value now. that is why in the second block, you can (read-only) borrow as much as you want from the RefCell.\nreferences https://doc.rust-lang.org/book/ch15-00-smart-pointers.html\n","wordCount":"823","inLanguage":"en","image":"https://khanh1998.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-12-11T13:33:55+07:00","dateModified":"2022-12-11T13:33:55+07:00","author":{"@type":"Person","name":"Khanh Bui"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://khanh1998.github.io/posts/a-note-about-rust-smart-pointer-and-deref/"},"publisher":{"@type":"Organization","name":"Khanh1998","logo":{"@type":"ImageObject","url":"https://khanh1998.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://khanh1998.github.io/ accesskey=h title="Khanh1998 (Alt + H)"><img src=https://khanh1998.github.io/favicon.ico alt aria-label=logo height=32>Khanh1998</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://khanh1998.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://khanh1998.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://khanh1998.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://khanh1998.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://khanh1998.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">A Note About Rust Smart Pointer and Deref</h1><div class=post-meta><span title='2022-12-11 13:33:55 +0700 +07'>December 11, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;823 words&nbsp;·&nbsp;Khanh Bui&nbsp;|&nbsp;<a href=https://github.com/khanh1998/khanh1998.github.io/blob/main/content/posts/a-note-about-rust-smart-pointer-and-deref.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-dereference--operator>the dereference (*) operator</a></li><li><a href=#the-smart-pointers>the smart pointers</a><ul><li><a href=#boxt><code>Box&lt;T></code></a></li><li><a href=#rct><code>Rc&lt;T></code></a></li><li><a href=#refcellt><code>RefCell&lt;T></code></a></li></ul></li><li><a href=#references>references</a></li></ul></nav></div></details></div><div class=post-content><p>this article assumes you have some basic knowledge about <a href=https://doc.rust-lang.org/book/ch15-00-smart-pointers.html>Rust smart pointers</a>.</p><h2 id=the-dereference--operator>the dereference (*) operator<a hidden class=anchor aria-hidden=true href=#the-dereference--operator>#</a></h2><p><em>dereference</em> operator <code>*</code> is used for getting the actual value from a reference:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span>: <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>in the above example, <code>b</code> is a reference to <code>a</code>, <code>*b</code> will return the value that <code>b</code> pointing to.</p><h2 id=the-smart-pointers>the smart pointers<a hidden class=anchor aria-hidden=true href=#the-smart-pointers>#</a></h2><h3 id=boxt><code>Box&lt;T></code><a hidden class=anchor aria-hidden=true href=#boxt>#</a></h3><p>here is an example of how you can init and modify the value of a Box:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>b</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>7</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>in the above example, I init a box with value 6 inside, then I changed the value to 7, and check the value inside the box with assert to ensure the change is affected.</p><p>in the first example of this post, we apply the dereference to a reference which is <code>&amp;i32</code>, but the data type of b now is <code>Box&lt;i32></code>, how can we apply to dereference to a <code>Box&lt;i32></code>?</p><p>the answer is the <code>Box&lt;T></code> is implemented the trait <a href=https://doc.rust-lang.org/alloc/boxed/struct.Box.html#impl-Deref-for-Box%3CT%2C%20A%3E>Deref</a> and <a href=https://doc.rust-lang.org/alloc/boxed/struct.Box.html#impl-DerefMut-for-Box%3CT%2C%20A%3E>DerefMut</a>, so when you write <code>*b</code>, the compiler implicitly translates it to <code>*(b.deref())</code> if you want to get the value or <code>*(b.deref_mut())</code> if you want to change the value.</p><p>if you have a <code>Box&lt;T></code>, the <code>deref</code> method returns a <code>&amp;T</code>, and <code>deref_mut</code> returns a <code>&amp;mut T</code>. after calling the <code>deref</code> method, you now have a reference to the actual value, therefore you can use the dereference operator on these references.</p><p>the above snippet can be explicitly rewritten as below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>b</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>c</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>i32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>deref_mut</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>7</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>d</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>deref</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>firstly, we create a new <code>box</code> to hold the value 6. then we call <code>deref_mut</code> to get a <code>&amp;mut i32</code>, in order to change the value inside the box. finally, we get a read-only reference <code>&amp;i32</code> to the value inside the box, by calling <code>deref</code>.</p><h3 id=rct><code>Rc&lt;T></code><a hidden class=anchor aria-hidden=true href=#rct>#</a></h3><p><code>Rc&lt;T></code> is quite similar to <code>Box&lt;T></code>, except that you can only read data in Rc, you cannot edit it. because Rc only implements the trait <code>Deref</code>, not implement <code>DerefMut</code>. Therefore, you can only call the <code>deref</code> method on Rc only, there is no such method <code>deref_mut</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// implicitly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>rc1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>rc1</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// explicitly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rc1</span><span class=p>.</span><span class=n>deref</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=refcellt><code>RefCell&lt;T></code><a hidden class=anchor aria-hidden=true href=#refcellt>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// wrong code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>ref_cell</span>: <span class=nc>RefCell</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>ref_cell</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>7</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>ref_cell</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>if you write code like the above example, you will get this error: type <code>RefCell&lt;{integer}></code> cannot be dereferenced. it’s because <code>RefCell&lt;i32></code> doesn’t implement either <code>Deref</code> or <code>DerefMut</code> traits. you can check this out on the docs of <a href=https://doc.rust-lang.org/core/cell/struct.RefCell.html>RefCell</a>.</p><p>the way <code>RefCell&lt;T></code> works is a bit different from <code>Box&lt;T></code>, to read or modify data inside <code>RefCell</code> you need to explicitly call method <code>borrow</code> or <code>borrow_mut</code> respectively.</p><p><code>borrow</code> will return a <code>Ref&lt;T></code> which implements trait <code>Deref</code>, and <code>borrow_mut</code> will return a <code>RefMut&lt;T></code> which implements both <code>DerefMut</code> and <code>Deref</code>.</p><p>because <code>Ref&lt;T></code> and <code>RefMut&lt;T></code> implements <code>Deref</code>, so we can use <em>dereference</em> operator on them.</p><p>so you can write code like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// implicit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>ref_cell</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=p>(</span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>())</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>7</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow</span><span class=p>()),</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// a bit explicit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>ref_cell</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=p>(</span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>().</span><span class=n>deref_mut</span><span class=p>())</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>7</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>deref</span><span class=p>()),</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>or, if you want more explicitly, I have this code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// wrong code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>ref_cell</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>a</span>: <span class=nc>RefMut</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>i32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>deref_mut</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>a</span>: <span class=nc>Ref</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>deref</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>if you run the above code, you will get this error: <code>already mutably borrowed: BorrowError</code>.</p><p>it’s because, in line number 2, you call <code>borrow_mut</code>, and in line number 3 you call <code>deref_mut</code> to get a mutability reference.</p><p>in line number 5, you call <code>borrow</code> in order to read the data inside <code>RefCell</code>, which is forbidden by Rust. you can’t have a read-only reference to the value that currently has a mutability reference to prevent the race condition.
so you can rewrite it as below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>ref_cell</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>a</span>: <span class=nc>RefMut</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>i32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>deref_mut</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>*</span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=c1>// borrow_mut will be drop here, at the end of block
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// there are no mutability reference to the value, so we can borrow.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>a</span>: <span class=nc>Ref</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ref_cell</span><span class=p>.</span><span class=n>borrow</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>deref</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>in the above code, the <code>borrow_mut</code> and <code>deref_mut</code> are put in the first block, so at the end of the first block, the mutability reference is dropped, there is no mutability reference to the value now. that is why in the second block, you can (read-only) borrow as much as you want from the <code>RefCell</code>.</p><h2 id=references>references<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://doc.rust-lang.org/book/ch15-00-smart-pointers.html>https://doc.rust-lang.org/book/ch15-00-smart-pointers.html</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://khanh1998.github.io/tags/rust/>Rust</a></li><li><a href=https://khanh1998.github.io/tags/cs/>Cs</a></li></ul><nav class=paginav><a class=prev href=https://khanh1998.github.io/posts/go-untyped-constant/><span class=title>« Prev</span><br><span>Why would sometimes 0.1 + 0.2 equals to 0.3, but sometimes it’s not in Go</span>
</a><a class=next href=https://khanh1998.github.io/posts/floyd-cycle-detection/><span class=title>Next »</span><br><span>Floyd’s cycle detection</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on x" href="https://x.com/intent/tweet/?text=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref&amp;url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f&amp;hashtags=rust%2ccs"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f&amp;title=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref&amp;summary=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref&amp;source=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f&title=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on whatsapp" href="https://api.whatsapp.com/send?text=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref%20-%20https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on telegram" href="https://telegram.me/share/url?text=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref&amp;url=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share A Note About Rust Smart Pointer and Deref on ycombinator" href="https://news.ycombinator.com/submitlink?t=A%20Note%20About%20Rust%20Smart%20Pointer%20and%20Deref&u=https%3a%2f%2fkhanh1998.github.io%2fposts%2fa-note-about-rust-smart-pointer-and-deref%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//khanh1998.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://khanh1998.github.io/>Khanh1998</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>